<?xml version="1.0" encoding="UTF-8"?>

<proposal href="proposals/WEBGL_es31/">
  <name>WEBGL_es31</name>
  <contact>
    <a href="https://www.khronos.org/webgl/public-mailing-list/">WebGL working group</a> (public_webgl 'at' khronos.org)
  </contact>
  <contributors>
    <contributor>Yunchao He,   Intel</contributor>
    <contributor>Members of the WebGL working group</contributor>
  </contributors>

  <number>k <!-- extension number in registry --></number>
  <depends>
    <api version="2.0"/>
  </depends>

  <overview>
    <!-- use mirrors if this extension wraps another -->
    <p>This extension exposes OpenGL ES 3.1 and ESSL 310 features to WebGL.</p>
    <p>This document mainly list the differences with WebGL 2 and OpenGL ES 3.1.</p>
  </overview>

  <idl xml:space="preserve">
[NoInterfaceObject]
interface WEBGL_es31 {
  const GLenum  GL_COMPUTE_SHADER                             = 0x91B9  // 7.1 (Table 7.1) shader types
  const GLenum  GL_MAX_COMPUTE_UNIFORM_BLOCKS                 = 0x91BB  // 7.6.2 uniform blocks
  const GLenum  GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS            = 0x91BC
  const GLenum  GL_MAX_COMPUTE_IMAGE_UNIFORMS                 = 0x91BD
  const GLenum  GL_MAX_COMPUTE_SHARED_MEMORY_SIZE             = 0x8262
  const GLenum  GL_MAX_COMPUTE_UNIFORM_COMPONENTS             = 0x8263  // 7.6 uniform variables
  const GLenum  GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS         = 0x8264  // 7.7 atomic counter buffer
  const GLenum  GL_MAX_COMPUTE_ATOMIC_COUNTERS                = 0x8265
  const GLenum  GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS    = 0x8266  // 7.6 uniform variables
  const GLenum  GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS         = 0x90EB
  const GLenum  GL_MAX_COMPUTE_WORK_GROUP_COUNT               = 0x91BE
  const GLenum  GL_MAX_COMPUTE_WORK_GROUP_SIZE                = 0x91BF
  const GLenum  GL_COMPUTE_WORK_GROUP_SIZE                    = 0x8267
  const GLenum  GL_DISPATCH_INDIRECT_BUFFER                   = 0x90EE  // 6.1 buffer types
  const GLenum  GL_DISPATCH_INDIRECT_BUFFER_BINDING           = 0x90EF
  const GLenum  GL_COMPUTE_SHADER_BIT                         = 0x00000020
  const GLenum  GL_DRAW_INDIRECT_BUFFER                       = 0x8F3F  // 6.1 buffer types
  const GLenum  GL_DRAW_INDIRECT_BUFFER_BINDING               = 0x8F43
  const GLenum  GL_MAX_UNIFORM_LOCATIONS                      = 0x826E
  const GLenum  GL_FRAMEBUFFER_DEFAULT_WIDTH                  = 0x9310
  const GLenum  GL_FRAMEBUFFER_DEFAULT_HEIGHT                 = 0x9311
  const GLenum  GL_FRAMEBUFFER_DEFAULT_SAMPLES                = 0x9313
  const GLenum  GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS = 0x9314
  const GLenum  GL_MAX_FRAMEBUFFER_WIDTH                      = 0x9315
  const GLenum  GL_MAX_FRAMEBUFFER_HEIGHT                     = 0x9316
  const GLenum  GL_MAX_FRAMEBUFFER_SAMPLES                    = 0x9318
  const GLenum  GL_UNIFORM                                    = 0x92E1
  const GLenum  GL_UNIFORM_BLOCK                              = 0x92E2
  const GLenum  GL_PROGRAM_INPUT                              = 0x92E3  // 7.3.1 program interface
  const GLenum  GL_PROGRAM_OUTPUT                             = 0x92E4  // 7.3.1 program interface
  const GLenum  GL_BUFFER_VARIABLE                            = 0x92E5  // 7.3.1 program interface
  const GLenum  GL_SHADER_STORAGE_BLOCK                       = 0x92E6  // 7.3.1 program interface
  const GLenum  GL_ATOMIC_COUNTER_BUFFER                      = 0x92C0  // 6.1 buffer types
  const GLenum  GL_TRANSFORM_FEEDBACK_VARYING                 = 0x92F4
  const GLenum  GL_ACTIVE_RESOURCES                           = 0x92F5
  const GLenum  GL_MAX_NAME_LENGTH                            = 0x92F6
  const GLenum  GL_MAX_NUM_ACTIVE_VARIABLES                   = 0x92F7
  const GLenum  GL_NAME_LENGTH                                = 0x92F9  // 7.3.1 program interface getProgramResourceiv
  const GLenum  GL_TYPE                                       = 0x92FA  // 7.3.1
  const GLenum  GL_ARRAY_SIZE                                 = 0x92FB  // 7.3.1
  const GLenum  GL_OFFSET                                     = 0x92FC  // 7.3.1
  const GLenum  GL_BLOCK_INDEX                                = 0x92FD  // 7.3.1
  const GLenum  GL_ARRAY_STRIDE                               = 0x92FE  // 7.3.1
  const GLenum  GL_MATRIX_STRIDE                              = 0x92FF  // 7.3.1
  const GLenum  GL_IS_ROW_MAJOR                               = 0x9300  // 7.3.1
  const GLenum  GL_ATOMIC_COUNTER_BUFFER_INDEX                = 0x9301  // 7.3.1
  const GLenum  GL_BUFFER_BINDING                             = 0x9302  // 7.3.1
  const GLenum  GL_BUFFER_DATA_SIZE                           = 0x9303  // 7.3.1
  const GLenum  GL_NUM_ACTIVE_VARIABLES                       = 0x9304  // 7.3.1
  const GLenum  GL_ACTIVE_VARIABLES                           = 0x9305  // 7.3.1
  const GLenum  GL_REFERENCED_BY_VERTEX_SHADER                = 0x9306  // 7.3.1
  const GLenum  GL_REFERENCED_BY_FRAGMENT_SHADER              = 0x930A  // 7.3.1
  const GLenum  GL_REFERENCED_BY_COMPUTE_SHADER               = 0x930B  // 7.3.1
  const GLenum  GL_TOP_LEVEL_ARRAY_SIZE                       = 0x930C  // 7.3.1
  const GLenum  GL_TOP_LEVEL_ARRAY_STRIDE                     = 0x930D  // 7.3.1
  const GLenum  GL_LOCATION                                   = 0x930E  // 7.3.1 program interface getProgramResourceiv
  const GLenum  GL_VERTEX_SHADER_BIT                          = 0x00000001
  const GLenum  GL_FRAGMENT_SHADER_BIT                        = 0x00000002
  const GLenum  GL_ALL_SHADER_BITS                            = 0xFFFFFFFF
  const GLenum  GL_PROGRAM_SEPARABLE                          = 0x8258  // 7.3 program object
  const GLenum  GL_ACTIVE_PROGRAM                             = 0x8259
  const GLenum  GL_PROGRAM_PIPELINE_BINDING                   = 0x825A
  const GLenum  GL_ATOMIC_COUNTER_BUFFER_BINDING              = 0x92C1
  const GLenum  GL_ATOMIC_COUNTER_BUFFER_START                = 0x92C2
  const GLenum  GL_ATOMIC_COUNTER_BUFFER_SIZE                 = 0x92C3
  const GLenum  GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS          = 0x92CC   // 7.7 atomic counter buffer
  const GLenum  GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS        = 0x92D0   // 7.7 atomic counter buffer
  const GLenum  GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS        = 0x92D1   // 7.7 atomic counter buffer
  const GLenum  GL_MAX_VERTEX_ATOMIC_COUNTERS                 = 0x92D2
  const GLenum  GL_MAX_FRAGMENT_ATOMIC_COUNTERS               = 0x92D6
  const GLenum  GL_MAX_COMBINED_ATOMIC_COUNTERS               = 0x92D7
  const GLenum  GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE             = 0x92D8
  const GLenum  GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS         = 0x92DC   // 7.7.2 atomic counter buffer bindings
  const GLenum  GL_ACTIVE_ATOMIC_COUNTER_BUFFERS              = 0x92D9
  const GLenum  GL_UNSIGNED_INT_ATOMIC_COUNTER                = 0x92DB
  const GLenum  GL_MAX_IMAGE_UNITS                            = 0x8F38   // 7.10 images
  const GLenum  GL_MAX_VERTEX_IMAGE_UNIFORMS                  = 0x90CA
  const GLenum  GL_MAX_FRAGMENT_IMAGE_UNIFORMS                = 0x90CE
  const GLenum  GL_MAX_COMBINED_IMAGE_UNIFORMS                = 0x90CF
  const GLenum  GL_IMAGE_BINDING_NAME                         = 0x8F3A
  const GLenum  GL_IMAGE_BINDING_LEVEL                        = 0x8F3B
  const GLenum  GL_IMAGE_BINDING_LAYERED                      = 0x8F3C
  const GLenum  GL_IMAGE_BINDING_LAYER                        = 0x8F3D
  const GLenum  GL_IMAGE_BINDING_ACCESS                       = 0x8F3E
  const GLenum  GL_IMAGE_BINDING_FORMAT                       = 0x906E
  const GLenum  GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT            = 0x00000001  // 7.11 shader memory access
  const GLenum  GL_ELEMENT_ARRAY_BARRIER_BIT                  = 0x00000002  // 7.11
  const GLenum  GL_UNIFORM_BARRIER_BIT                        = 0x00000004  // 7.11
  const GLenum  GL_TEXTURE_FETCH_BARRIER_BIT                  = 0x00000008  // 7.11
  const GLenum  GL_SHADER_IMAGE_ACCESS_BARRIER_BIT            = 0x00000020  // 7.11
  const GLenum  GL_COMMAND_BARRIER_BIT                        = 0x00000040  // 7.11
  const GLenum  GL_PIXEL_BUFFER_BARRIER_BIT                   = 0x00000080  // 7.11
  const GLenum  GL_TEXTURE_UPDATE_BARRIER_BIT                 = 0x00000100  // 7.11
  const GLenum  GL_BUFFER_UPDATE_BARRIER_BIT                  = 0x00000200  // 7.11
  const GLenum  GL_FRAMEBUFFER_BARRIER_BIT                    = 0x00000400  // 7.11
  const GLenum  GL_TRANSFORM_FEEDBACK_BARRIER_BIT             = 0x00000800  // 7.11
  const GLenum  GL_ATOMIC_COUNTER_BARRIER_BIT                 = 0x00001000  // 7.11
  const GLenum  GL_SHADER_STORAGE_BARRIER_BIT                 = 0x00002000  // 7.11
  const GLenum  GL_ALL_BARRIER_BITS                           = 0xFFFFFFFF  // 7.11 shader memory access
  const GLenum  GL_IMAGE_2D                                   = 0x904D
  const GLenum  GL_IMAGE_3D                                   = 0x904E
  const GLenum  GL_IMAGE_CUBE                                 = 0x9050
  const GLenum  GL_IMAGE_2D_ARRAY                             = 0x9053
  const GLenum  GL_INT_IMAGE_2D                               = 0x9058
  const GLenum  GL_INT_IMAGE_3D                               = 0x9059
  const GLenum  GL_INT_IMAGE_CUBE                             = 0x905B
  const GLenum  GL_INT_IMAGE_2D_ARRAY                         = 0x905E
  const GLenum  GL_UNSIGNED_INT_IMAGE_2D                      = 0x9063
  const GLenum  GL_UNSIGNED_INT_IMAGE_3D                      = 0x9064
  const GLenum  GL_UNSIGNED_INT_IMAGE_CUBE                    = 0x9066
  const GLenum  GL_UNSIGNED_INT_IMAGE_2D_ARRAY                = 0x9069
  const GLenum  GL_IMAGE_FORMAT_COMPATIBILITY_TYPE            = 0x90C7
  const GLenum  GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE         = 0x90C8
  const GLenum  GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS        = 0x90C9
  const GLenum  GL_READ_ONLY                                  = 0x88B8
  const GLenum  GL_WRITE_ONLY                                 = 0x88B9
  const GLenum  GL_READ_WRITE                                 = 0x88BA
  const GLenum  GL_SHADER_STORAGE_BUFFER                      = 0x90D2  // 6.1 buffer types
  const GLenum  GL_SHADER_STORAGE_BUFFER_BINDING              = 0x90D3  // 6.7 buffer object state
  const GLenum  GL_SHADER_STORAGE_BUFFER_START                = 0x90D4  // 6.7 buffer object state
  const GLenum  GL_SHADER_STORAGE_BUFFER_SIZE                 = 0x90D5  // 6.7 buffer object state
  const GLenum  GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS           = 0x90D6  // 7.8 shader buffer variables and shader storage blocks
  const GLenum  GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS         = 0x90DA  // 7.8
  const GLenum  GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS          = 0x90DB  // 7.8
  const GLenum  GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS         = 0x90DC  // 7.8
  const GLenum  GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS         = 0x90DD  // 6.7
  const GLenum  GL_MAX_SHADER_STORAGE_BLOCK_SIZE              = 0x90DE  // 7.8
  const GLenum  GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT     = 0x90DF  // 6.7
  const GLenum  GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES       = 0x8F39
  const GLenum  GL_DEPTH_STENCIL_TEXTURE_MODE                 = 0x90EA
  const GLenum  GL_STENCIL_INDEX                              = 0x1901
  const GLenum  GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET          = 0x8E5E
  const GLenum  GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET          = 0x8E5F
  const GLenum  GL_SAMPLE_POSITION                            = 0x8E50
  const GLenum  GL_SAMPLE_MASK                                = 0x8E51
  const GLenum  GL_SAMPLE_MASK_VALUE                          = 0x8E52
  const GLenum  GL_TEXTURE_2D_MULTISAMPLE                     = 0x9100
  const GLenum  GL_MAX_SAMPLE_MASK_WORDS                      = 0x8E59
  const GLenum  GL_MAX_COLOR_TEXTURE_SAMPLES                  = 0x910E
  const GLenum  GL_MAX_DEPTH_TEXTURE_SAMPLES                  = 0x910F
  const GLenum  GL_MAX_INTEGER_SAMPLES                        = 0x9110
  const GLenum  GL_TEXTURE_BINDING_2D_MULTISAMPLE             = 0x9104
  const GLenum  GL_TEXTURE_SAMPLES                            = 0x9106
  const GLenum  GL_TEXTURE_FIXED_SAMPLE_LOCATIONS             = 0x9107
  const GLenum  GL_TEXTURE_WIDTH                              = 0x1000
  const GLenum  GL_TEXTURE_HEIGHT                             = 0x1001
  const GLenum  GL_TEXTURE_DEPTH                              = 0x8071
  const GLenum  GL_TEXTURE_INTERNAL_FORMAT                    = 0x1003
  const GLenum  GL_TEXTURE_RED_SIZE                           = 0x805C
  const GLenum  GL_TEXTURE_GREEN_SIZE                         = 0x805D
  const GLenum  GL_TEXTURE_BLUE_SIZE                          = 0x805E
  const GLenum  GL_TEXTURE_ALPHA_SIZE                         = 0x805F
  const GLenum  GL_TEXTURE_DEPTH_SIZE                         = 0x884A
  const GLenum  GL_TEXTURE_STENCIL_SIZE                       = 0x88F1
  const GLenum  GL_TEXTURE_SHARED_SIZE                        = 0x8C3F
  const GLenum  GL_TEXTURE_RED_TYPE                           = 0x8C10
  const GLenum  GL_TEXTURE_GREEN_TYPE                         = 0x8C11
  const GLenum  GL_TEXTURE_BLUE_TYPE                          = 0x8C12
  const GLenum  GL_TEXTURE_ALPHA_TYPE                         = 0x8C13
  const GLenum  GL_TEXTURE_DEPTH_TYPE                         = 0x8C16
  const GLenum  GL_TEXTURE_COMPRESSED                         = 0x86A1
  const GLenum  GL_SAMPLER_2D_MULTISAMPLE                     = 0x9108
  const GLenum  GL_INT_SAMPLER_2D_MULTISAMPLE                 = 0x9109
  const GLenum  GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE        = 0x910A
  const GLenum  GL_VERTEX_ATTRIB_BINDING                      = 0x82D4
  const GLenum  GL_VERTEX_ATTRIB_RELATIVE_OFFSET              = 0x82D5
  const GLenum  GL_VERTEX_BINDING_DIVISOR                     = 0x82D6
  const GLenum  GL_VERTEX_BINDING_OFFSET                      = 0x82D7
  const GLenum  GL_VERTEX_BINDING_STRIDE                      = 0x82D8
  const GLenum  GL_VERTEX_BINDING_BUFFER                      = 0x8F4F
  const GLenum  GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET          = 0x82D9
  const GLenum  GL_MAX_VERTEX_ATTRIB_BINDINGS                 = 0x82DA
  const GLenum  GL_MAX_VERTEX_ATTRIB_STRIDE                   = 0x82E5

  void dispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
  void dispatchComputeIndirect(GLintptr offset);

  void drawArraysIndirect(GLenum mode, GLintptr offset);
  void drawElementsIndirect(GLenum mode, GLenum type, GLintptr offset);

  void framebufferParameter(GLenum target, GLenum pname, GLint param);
  any getFramebufferParameter(GLenum target, GLenum pname);

  void getProgramInterfaceiv(WebGLProgram? program, GLenum programInterface, GLenum pname, GLint *params);  // 7.3.1 program interface
  GLuint getProgramResourceIndex(WebGLProgram? program, GLenum programInterface, const GLchar *name); // 7.3.1 program interface
  void getProgramResourceName(WebGLProgram? program, GLenum programInterface, GLuint index,
                              GLsizei bufSize, GLsizei *length, GLchar *name);  // 7.3.1 program interface
  void getProgramResourceiv(WebGLProgram? program, GLenum programInterface, GLuint index,
                            GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params); // 7.3.1 program interface
  GLint getProgramResourceLocation(WebGLProgram? program, GLenum programInterface, const GLchar *name);  // 7.3.1 program interface

  void programParameter(WebGLProgram? program, GLenum pname, GLint value);
  GLuint createShaderProgram(GLenum type, GLsizei count, DOMString source); // 7.3 program object
  WebGLProgramPipeline? createProgramPipeline();
  void deleteProgramPipeline(WebGLProgramPipeline? pipeline);  // 7.4 program pipeline object
  void bindProgramPipeline(WebGLProgramPipeline? pipeline);  // 7.4 program pipeline object
  [WebGLHandlesContextLoss] GLboolean isProgramPipeline(WebGLProgramPipeline? pipeline);  // 7.4 program pipeline object
  void activeShaderProgram(WebGLProgramPipeline? pipeline, WebGLProgram? program);  // 7.4 program pipeline
  void useProgramStages(WebGLProgramPipeline? pipeline, GLbitfield stages, WebGLProgram? program);  // 7.4 program pipeline
  void validateProgramPipeline(WebGLProgramPipeline? pipeline);
  DOMString? getProgramPipelineInfoLog(WebGLProgramPipeline? pipeline); // 7.12
  any getProgramPipelineParameter(WebGLProgramPipeline? pipeline, GLenum pname);  // 7.12 shader, program, and program pipelie queries

  void programUniform1i(WebGLProgram? program, WebGLUniformLocation? location, GLint v0);  // 7.6.1 uniform variables
  void programUniform2i(WebGLProgram? program, WebGLUniformLocation? location, GLint v0, GLint v1);  // 7.6.1
  void programUniform3i(WebGLProgram? program, WebGLUniformLocation? location, GLint v0, GLint v1, GLint v2);  // 7.6.1
  void programUniform4i(WebGLProgram? program, WebGLUniformLocation? location, GLint v0, GLint v1, GLint v2, GLint v3);  // 7.6.1

  void programUniform1ui(WebGLProgram? program, WebGLUniformLocation? location, GLuint v0);
  void programUniform2ui(WebGLProgram? program, WebGLUniformLocation? location, GLuint v0, GLuint v1);
  void programUniform3ui(WebGLProgram? program, WebGLUniformLocation? location, GLuint v0, GLuint v1, GLuint v2);
  void programUniform4ui(WebGLProgram? program, WebGLUniformLocation? location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);

  void programUniform1f(WebGLProgram? program, WebGLUniformLocation? location, GLfloat v0);
  void programUniform2f(WebGLProgram? program, WebGLUniformLocation? location, GLfloat v0, GLfloat v1);
  void programUniform3f(WebGLProgram? program, WebGLUniformLocation? location, GLfloat v0, GLfloat v1, GLfloat v2);
  void programUniform4f(WebGLProgram? program, WebGLUniformLocation? location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);

  void programUniform1iv(WebGLProgram? program, WebGLUniformLocation? location, GLsizei count, Int32List data);
  void programUniform2iv(WebGLProgram? program, WebGLUniformLocation? location, GLsizei count, Int32List data);
  void programUniform3iv(WebGLProgram? program, WebGLUniformLocation? location, GLsizei count, Int32List data);
  void programUniform4iv(WebGLProgram? program, WebGLUniformLocation? location, GLsizei count, Int32List data);

  void programUniform1uiv(WebGLProgram? program, WebGLUniformLocation? location, GLsizei count, Uint32List data);
  void programUniform2uiv(WebGLProgram? program, WebGLUniformLocation? location, GLsizei count, Uint32List data);
  void programUniform3uiv(WebGLProgram? program, WebGLUniformLocation? location, GLsizei count, Uint32List data);
  void programUniform4uiv(WebGLProgram? program, WebGLUniformLocation? location, GLsizei count, Uint32List data);

  void programUniform1fv(WebGLProgram? program, WebGLUniformLocation? location, GLsizei count, Float32List data);
  void programUniform2fv(WebGLProgram? program, WebGLUniformLocation? location, GLsizei count, Float32List data);
  void programUniform3fv(WebGLProgram? program, WebGLUniformLocation? location, GLsizei count, Float32List data);
  void programUniform4fv(WebGLProgram? program, WebGLUniformLocation? location, GLsizei count, Float32List data);

  void programUniformMatrix2fv(WebGLProgram? program, WebGLUniformLocation? location, GLsizei count,
                               GLboolean transpose, Float32List data);
  void programUniformMatrix3fv(WebGLProgram? program, WebGLUniformLocation? location, GLsizei count,
                               GLboolean transpose, Float32List data);
  void programUniformMatrix4fv(WebGLProgram? program, WebGLUniformLocation? location, GLsizei count,
                               GLboolean transpose, Float32List data);
  void programUniformMatrix2x3fv(WebGLProgram? program, WebGLUniformLocation? location, GLsizei count,
                                 GLboolean transpose, Float32List data);
  void programUniformMatrix3x2fv(WebGLProgram? program, WebGLUniformLocation? location, GLsizei count,
                                 GLboolean transpose, Float32List data);
  void programUniformMatrix2x4fv(WebGLProgram? program, WebGLUniformLocation? location, GLsizei count,
                                 GLboolean transpose, Float32List data);
  void programUniformMatrix4x2fv(WebGLProgram? program, WebGLUniformLocation? location, GLsizei count,
                                 GLboolean transpose, Float32List data);
  void programUniformMatrix3x4fv(WebGLProgram? program, WebGLUniformLocation? location, GLsizei count,
                                 GLboolean transpose, Float32List data);
  void programUniformMatrix4x3fv(WebGLProgram? program, WebGLUniformLocation? location, GLsizei count,
                                 GLboolean transpose, Float32List data);  // 7.6.1 uniform variables


  void bindImageTexture(GLuint unit, WebGLTexture? texture, GLint level,
                        GLboolean layered, GLint layer, GLenum access, GLenum format);

  void memoryBarrier(GLbitfield barriers);  // 7.11 shader memory access
  void memoryBarrierByRegion(GLbitfield barriers);  // 7.11 shader memory access

  void texStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat,
                               GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
  any getTexLevelParameter(GLenum target, GLint level, GLenum pname);
  any getMultisample(GLenum pname, GLuint index);
  void sampleMask(GLuint index, GLbitfield mask);


  void bindVertexBuffer(GLuint bindingindex, WebGLBuffer? buffer, GLintptr offset, GLsizei stride);
  void vertexAttribFormat(GLuint attribindex, GLint size, GLenum type,
                          GLboolean normalized, GLuint relativeoffset);
  void vertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
  void vertexAttribBinding(GLuint attribindex, GLuint bindingindex);
  void vertexBindingDivisor(GLuint bindingindex, GLuint divisor);
}; // interface WEBGL_es31
  </idl>

  <h2>New DOM Interface</h2>
  <!-- New DOM Interface -->
  <h3>WebGLProgramPipeline</h3>

  <newfun>
    <p> <code>Framebuffer Object</code> </p>
    <function name="framebufferParameter" type="void">
      <param name="target" type="GLenum"/>
      <param name="pname" type="GLenum"/>
      <param name="param" type="GLint"/>
      Set framebuffer default parameter. See glFramebufferParameteri at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-9.2.1">
          OpenGL ES 3.1 Section 9.2.1</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glFramebufferParameteri.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="getFramebufferParameter" type="any">
      <param name="target" type="GLenum"/>
      <param name="pname" type="GLenum"/>
      Query framebuffer default parameter. See glGetFramebufferParameteriv at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-9.2.3">
          OpenGL ES 3.1 Section 9.2.3</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glGetFramebufferParameteriv.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
  </newfun>

  <newfun>
    <p> <code>Texture Object</code> </p>
    <function name="texStorage2DMultisample" type="void">
      <param name="target" type="GLenum"/>
      <param name="samples" type="GLsizei"/>
      <param name="internalformat" type="GLenum"/>
      <param name="width" type="GLsizei"/>
      <param name="height" type="GLsizei"/>
      <param name="fixedSampleLocations" type="GLboolean"/>
      Establish the data storage, format, dimensions, and number of samples of a multisample
      texture's image. See glTexStorage2DMultisample at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-8.8">
          OpenGL ES 3.1 Section 8.8</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glTexStorage2DMultisample.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="getTexLevelParameter" type="any">
      <param name="target" type="GLenum"/>
      <param name="level" type="GLint"/>
      <param name="value" type="GLenum"/>
      Query the level-of-detail information of the given pname for the currently bound texture
      specified by target. See glGetTexLevelParameter{if}v at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-8.10.3">
          OpenGL ES 3.1 Section 8.10.3</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glGetTexLevelParameter.xhtml"
          class="nonnormative">man page</a>
      </span>
      <br/>
      The requested pname and its return type are given in the following table:
      <br/>
      <table width="30%">
        <tr><th>pname</th><th>returned type</th></tr>
        <tr><td>TEXTURE_SAMPLES</td><td>GLuint</td></tr>
        <tr><td>TEXTURE_FIXED_SAMPLE_LOCATIONS</td><td>GLboolean</td></tr>
        <tr><td>TEXTURE_WIDTH</td><td>GLuint</td></tr>
        <tr><td>TEXTURE_HEIGHT</td><td>GLuint</td></tr>
        <tr><td>TEXTURE_DEPTH</td><td>GLuint</td></tr>
        <tr><td>TEXTURE_INTERNAL_FORMAT</td><td>GLenum</td></tr>
        <tr><td>TEXTURE_RED_SIZE</td><td>GLuint</td></tr>
        <tr><td>TEXTURE_GREEN_SIZE</td><td>GLuint</td></tr>
        <tr><td>TEXTURE_BLUE_SIZE</td><td>GLuint</td></tr>
        <tr><td>TEXTURE_ALPHA_SIZE</td><td>GLuint</td></tr>
        <tr><td>TEXTURE_DEPTH_SIZE</td><td>GLuint</td></tr>
        <tr><td>TEXTURE_STENCIL_SIZE</td><td>GLuint</td></tr>
        <tr><td>TEXTURE_SHARED_SIZE</td><td>GLuint</td></tr>
        <tr><td>TEXTURE_RED_TYPE</td><td>GLenum</td></tr>
        <tr><td>TEXTURE_GREEN_TYPE</td><td>GLenum</td></tr>
        <tr><td>TEXTURE_BLUE_TYPE</td><td>GLenum</td></tr>
        <tr><td>TEXTURE_ALPHA_TYPE</td><td>GLenum</td></tr>
        <tr><td>TEXTURE_DEPTH_TYPE</td><td>GLenum</td></tr>
        <tr><td>TEXTURE_COMPRESSED</td><td>GLboolean</td></tr>
      </table>
    </function>
  </newfun>

  <newfun>
    <p> <code>Sampler Object</code> </p>
    <function name="getMultisample" type="any">
      <param name="pname" type="GLenum"/>
      <param name="index" type="GLuint"/>
      Query the location of a given sample within the pixel. See glGetMultisamplefv at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-13.2.1">
          OpenGL ES 3.1 Section 13.2.1</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glGetMultisamplefv.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="sampleMask" type="void">
      <param name="index" type="GLuint"/>
      <param name="mask" type="GLbitfield"/>
      Specify the sample mask value to mask for desired mask of index. See glSampleMaski at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-13.6.3">
          OpenGL ES 3.1 Section 13.6.3</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glSampleMaski.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
  </newfun>

  <newfun>
    <p> <code>Programs, Shaders and Program Pipelines</code> </p>
    <function name="programParameter" type="void">
      <param name="program" type="WebGLProgram?"/>
      <param name="pname" type="GLenum"/>
      <param name="value" type="GLint"/>
      Set program parameter given a program. The only support parameter is PROGRAM_SEPARABLE. See glProgramParameteri at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.3">
          OpenGL ES 3.1 Section 7.3</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glProgramParameteri.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="createShaderProgram" type="void">
      <param name="type" type="GLenum"/>
      <param name="count" type="GLsizei"/>
      <param name="source" type="DOMString"/>
      Create a standalone separable program from an array of null-terminated source code string for a single shader type. See glCreateShaderProgramv at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.3">
          OpenGL ES 3.1 Section 7.3</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glCreateShaderProgramv.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="createProgramPipeline" type="WebGLProgramPipeline?">
	  Create a WebGLProgramPipeline object and initialize it with a program pipeline name like genProgramPipelines. See glGenProgramPipelines at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.4">
          OpenGL ES 3.1 Section 7.4</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glGenProgramPipelines.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="deleteProgramPipeline" type="void">
      <param name="pipeline" type="WebGLProgramPipeline?"/>
	  Delete a WebGLProgramPipeline object <code>pipeline</code>. See glDeleteProgramPipelines at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.4">
          OpenGL ES 3.1 Section 7.4</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glDeleteProgramPipelines.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="bindProgramPipeline" type="void">
      <param name="pipeline" type="WebGLProgramPipeline?"/>
	  Bind a WebGLProgramPipeline object <code>pipeline</code>. See glBindProgramPipeline at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.4">
          OpenGL ES 3.1 Section 7.4</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glBindProgramPipeline.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="isProgramPipeline" type="[WebGLHandlesContextLoss] GLboolean">
      <param name="pipeline" type="WebGLProgramPipeline?"/>
	  Return true if the passed WebGLProgramPipeline is valid and false otherwise. See glIsProgramPipeline at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.4">
          OpenGL ES 3.1 Section 7.4</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glIsProgramPipeline.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="activeShaderProgram" type="void">
      <param name="pipeline" type="WebGLProgramPipeline"/>
      <param name="program" type="WebGLProgram"/>
	  Set the linked named by <code>program</code> to be the active program used for uniform updates  for the program pipeline object <code>pipeline</code>. See glActiveShaderProgram at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.4">
          OpenGL ES 3.1 Section 7.4</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glActiveShaderProgram.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="useProgramStages" type="void">
      <param name="pipeline" type="WebGLProgramPipeline?"/>
      <param name="stages" type="GLbitfield"/>
      <param name="program" type="WebGLProgram?"/>
	  Associate one or more shader stages in program <code>program</code> with the program pipeline <code>pipeline</code>. See glUseProgramStages at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.4">
          OpenGL ES 3.1 Section 7.4</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glIsProgramStages.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="validateProgramPipeline" type="void">
      <param name="pipeline" type="WebGLProgramPipeline?"/>
	  Validate the program pipeline object <code>pipeline</code> against the current GL state. See glValidateProgramPipeline at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-11.1.3.11">
          OpenGL ES 3.1 Section 11.1.3.11</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glValidateProgramPipeline.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="getProgramPipelineInfoLog" type="DOMString?">
      <param name="pipeline" type="WebGLProgramPipeline?"/>
	  Return program pipeline infomation log give <code>pipeline</code>. See glGetProgramPipelineInfoLog at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.12">
          OpenGL ES 3.1 Section 7.12</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glIsProgramPipeline.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="getProgramPipelineParameter" type="any">
      <param name="pipeline" type="WebGLProgramPipeline?"/>
      <param name="pname" type="GLenum"/>
	  Query program pipeline parameter <code>pname</code> give <code>pipeline</code>. See glGetProgramPipelineiv at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.12">
          OpenGL ES 3.1 Section 7.12</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glGetProgramPipelineiv.xhtml"
          class="nonnormative">man page</a>
      </span>
      <br/>
      The requested pname and its return type are given in the following table:
      <br/>
      <table width="30%">
        <tr><th>pname</th><th>returned type</th></tr>
        <tr><td>ACTIVE_PROGRAM</td><td>GLint</td></tr>
        <tr><td>VALIDATE_STATUS</td><td>GLboolean</td></tr>
      </table>
    </function>
  </newfun>

  <newfun>
    <p> <code>Uniforms and Attributes</code> </p>
    <function name="programUniform[1234][if]" type="void">
      <param name="program" type="WebGLProgram?"/>
      <param name="location" type="WebGLUniformLocation?"/>
	  <param name="..."/>
      Set uniform value for a given program. See glProgramUniform[1234][if] at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.6.1">
          OpenGL ES 3.1 Section 7.6.1</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glProgramUniform.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="programUniform[1234][if]v" type="void">
      <param name="program" type="WebGLProgram?"/>
      <param name="location" type="WebGLUniformLocation?"/>
	  <param name="..."/>
      Set uniform value for a given program. See glProgramUniform[1234][if]v at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.6.1">
          OpenGL ES 3.1 Section 7.6.1</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glProgramUniform.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="programUniform[1234]ui" type="void">
      <param name="program" type="WebGLProgram?"/>
      <param name="location" type="WebGLUniformLocation?"/>
	  <param name="..."/>
      Set uniform value for a given program. See glProgramUniform[1234]ui at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.6.1">
          OpenGL ES 3.1 Section 7.6.1</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glProgramUniform.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="programUniform[1234]uiv" type="void">
      <param name="program" type="WebGLProgram?"/>
      <param name="location" type="WebGLUniformLocation?"/>
	  <param name="..."/>
      Set uniform value for a given program. See glProgramUniform[1234]uiv at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.6.1">
          OpenGL ES 3.1 Section 7.6.1</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glProgramUniform.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="programUniformMatrix[234][f]v" type="void">
      <param name="program" type="WebGLProgram?"/>
      <param name="location" type="WebGLUniformLocation?"/>
      <param name="count" type="GLsizei"/>
      <param name="transpose" type="GLboolean"/>
	  <param name="..."/>
      Set uniform value for a given program. See glProgramUniform[234][f]v at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.6.1">
          OpenGL ES 3.1 Section 7.6.1</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glProgramUniform.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="programUniformMatrix[2x3, 3x2, 2x4, 4x2, 3x4, 4x3][f]v" type="void">
      <param name="program" type="WebGLProgram?"/>
      <param name="location" type="WebGLUniformLocation?"/>
      <param name="count" type="GLsizei"/>
      <param name="transpose" type="GLboolean"/>
	  <param name="..."/>
      Set uniform value for a given program. See glProgramUniformMatirx[2x3, 3x2, 2x4, 4x2, 3x4, 4x3][f]v at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.6.1">
          OpenGL ES 3.1 Section 7.6.1</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glProgramUniform.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="bindVertexBuffer" type="void">
      <param name="bindingindex" type="GLuint"/>
      <param name="buffer" type="WebGLBuffer?"/>
      <param name="offset" type="GLintptr"/>
      <param name="stride" type="GLsizei"/>
	  Bind vertex buffer to the binding point <code>bindingindex</code>. See glBindVertexBuffer at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-10.3.1">
          OpenGL ES 3.1 Section 10.3.1</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glBindVertexBuffer.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="vertexAttribFormat" type="void">
      <param name="attribindex" type="GLuint"/>
      <param name="size" type="GLint"/>
      <param name="type" type="GLenum"/>
      <param name="normalized" type="GLboolean"/>
      <param name="relativeoffset" type="GLuint"/>
	  Describe the orgnization of vertex arrays. See glVertexAttribFormat at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-10.3.1">
          OpenGL ES 3.1 Section 10.3.1</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glVertexAttribFormat.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="vertexAttribIFormat" type="void">
      <param name="attribindex" type="GLuint"/>
      <param name="size" type="GLint"/>
      <param name="type" type="GLenum"/>
      <param name="relativeoffset" type="GLuint"/>
	  Describe the orgnization of vertex arrays. See glVertexAttribIFormat at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-10.3.1">
          OpenGL ES 3.1 Section 10.3.1</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glVertexAttribIFormat.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="vertexAttribBinding" type="void">
      <param name="attribindex" type="GLuint"/>
      <param name="bindingindex" type="GLuint"/>
	  Set the association between a vertex attribute and the vertex buffer binding. See glVertexAttribBinding at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-10.3.1">
          OpenGL ES 3.1 Section 10.3.1</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glVertexAttribBinding.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="vertexBindingDivisor" type="void">
      <param name="bindingindex" type="GLuint"/>
      <param name="divisor" type="GLuint"/>
	  Set the <code>advisor</code> value for attributes taken from the buffer bound to <code>bindingindex</code> between a vertex attribute and the vertex buffer binding. See glVertexBindingDivisor at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-10.3.2">
          OpenGL ES 3.1 Section 10.3.2</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glVertexBindingDivisor.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
  </newfun>

  <newfun>
    <p> <code>Writing to the drawing buffer</code> </p>
    <function name="drawArraysIndirect" type="void">
      <param name="mode" type="GLenum"/>
      <param name="offset" type="GLintptr"/>
	  Draw geometry with vertices by reading parameters via indirect buffer. See glDrawArraysIndirect at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-10.5">
          OpenGL ES 3.1 Section 10.5</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glDrawArraysIndirect.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="drawElementsIndirect" type="void">
      <param name="mode" type="GLenum"/>
      <param name="type" type="GLenum"/>
      <param name="offset" type="GLintptr"/>
	  Draw geometry with indexed vertices by reading parameters via indirect buffer. See glDrawElementsIndirect at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-10.5">
          OpenGL ES 3.1 Section 10.5</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glDrawElementsIndirect.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
  </newfun>

  <newfun>
    <p> <code>Program Interface Query</code> </p>
  ?? void getProgramInterfaceiv(WebGLProgram? program, GLenum programInterface, GLenum pname, GLint *params);
  GLuint getProgramResourceIndex(WebGLProgram? program, GLenum programInterface, const GLchar *name);
  void getProgramResourceName(WebGLProgram? program, GLenum programInterface, GLuint index,
                              GLsizei bufSize, GLsizei *length, GLchar *name);
  void getProgramResourceiv(WebGLProgram? program, GLenum programInterface, GLuint index,
                            GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params);
  GLint getProgramResourceLocation(WebGLProgram? program, GLenum programInterface, const GLchar *name);
    <function name="getProgramInterfaceParameter" type="any">
      <param name="program" type="WebGLProgram?"/>
      <param name="programInterface" type="GLenum"/>
      <param name="pname" type="GLenum"/>
	  Query a property of the interface <code>programInterface</code> in program <code>program</code>. See glGetProgramInterfaceiv at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.3.1.1">
          OpenGL ES 3.1 Section 7.3.1.1</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glGetProgramInterfaceiv.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="getProgramResource" type="void">
      <param name="program" type="WebGLProgram?"/>
      <param name="programInterface" type="GLenum"/>
      <param name="index" type="GLuint"/>
      <param name="propCount" type="GLsizei"/>
      <param name="props" type="GLenum *"/>
      <param name="bufSize" type="GLsizei"/>
      <param name="length" type="GLsizei *"/>
      <param name="params" type="GLint *"/>
	  Query multiple properties of the interface <code>programInterface</code> in program <code>program</code>. See glGetProgramResourceiv at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.3.1.1">
          OpenGL ES 3.1 Section 7.3.1.1</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glGetProgramResourceiv.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="getProgramResourceName" type="void">
      <param name="program" type="WebGLProgram?"/>
      <param name="programInterface" type="GLenum"/>
      <param name="index" type="GLuint"/>
      <param name="bufSize" type="GLsizei"/>
      <param name="length" type="GLsizei *"/>
      <param name="params" type="GLint *"/>
	  Query the name string assigned to the single active resource with an index of <code>index</code> in the interface <code>programInterface</code> in program <code>program</code>. See glGetProgramResourceName at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.3.1.1">
          OpenGL ES 3.1 Section 7.3.1.1</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glGetProgramResourceName.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="getProgramResourceIndex" type="GLuint">
      <param name="program" type="WebGLProgram?"/>
      <param name="programInterface" type="GLenum"/>
      <param name="name" type="const char *"/>
	  Query the unsigned integer index assigned to a resource named <code>name</code> in the interface <code>programInterface</code> in program <code>program</code>. See glGetProgramResourceIndex at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.3.1.1">
          OpenGL ES 3.1 Section 7.3.1.1</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glGetProgramResourceIndex.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="getProgramResourceLocation" type="void">
      <param name="program" type="WebGLProgram?"/>
      <param name="programInterface" type="GLenum"/>
      <param name="name" type="const char *"/>
	  Query the location assigned to a resource named <code>name</code> in the interface <code>programInterface</code> in program <code>program</code>. See glGetProgramResourceLocation at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.3.1.1">
          OpenGL ES 3.1 Section 7.3.1.1</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glGetProgramResourceLocation.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
  </newfun>

  <newfun>
    <p> <code>Image Object</code> </p>
    <function name="bindImageTexture" type="void">
      <param name="unit" type="GLuint"/>
      <param name="texture" type="WebGLTexture?"/>
      <param name="level" type="GLint"/>
      <param name="layered" type="GLboolean"/>
      <param name="layer" type="GLint"/>
      <param name="access" type="GLenum"/>
      <param name="format" type="GLenum"/>
	  Bind a texture to a image unit for image load and store. See glBindImageTexture at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-8.22">
          OpenGL ES 3.1 Section 8.22</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glBindImageTexture.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
  </newfun>

  <newfun>
    <p> <code>Memory Barrier Object</code> </p>
    <function name="memoryBarrior" type="void">
      <param name="barriers" type="GLbitfield"/>
	  Define a barrier ordering the memory transactions issued prior to the command relative to those issued after the barrier. See glMemoryBarrier at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.11.2">
          OpenGL ES 3.1 Section 7.11.2</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glMemoryBarrier.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="memoryBarriorByRegion" type="void">
      <param name="barriers" type="GLbitfield"/>
	  With restrictions, define a barrier ordering the memory transactions issued prior to the command relative to those issued after the barrier. See glMemoryBarrier at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.11.2">
          OpenGL ES 3.1 Section 7.11.2</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glMemoryBarrierByRegion.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
  </newfun>

  <newfun>
    <p> <code>Dispatch Computation</code> </p>
    <function name="dispatchCompute" type="void">
      <param name="num_groups_x" type="GLuint"/>
      <param name="num_groups_y" type="GLuint"/>
      <param name="num_groups_z" type="GLuint"/>
	  Launch one or more work groups and start compute pipeline. See glDispatchCompute at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-17">
          OpenGL ES 3.1 Section 17</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glDispatchCompute.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
    <function name="dispatchComputeIndirect" type="void">
      <param name="offset" type="GLintptr"/>
	  Launch one or more work groups and start compute pipeline, with parameter stored in a buffer from offset <code>offset</code>. See glDispatchComputeIndirect at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-17">
          OpenGL ES 3.1 Section 17</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glDispatchComputeIndirect.xhtml"
          class="nonnormative">man page</a>
      </span>
    </function>
  </newfun>

  <!-- new tokens -->

  <newtok>
    <p> <code>More Shader Type</code> </p>
    <function name="createShader" type="WebGLShader?">
      <param name="type" type="GLenum"/>
      <code>type</code> accept the following parameters.
      <br/>
      <table width="30%">
        <tr><th>type</th></tr>
        <tr><td>COMPUTE_SHADER</td></tr>
      </table>
      <code>COMPUTE_SHADER</code> is also supported by corresponding APIs like <code>createShaderProgram</code>, among other APIs.
    </function>
  </newtok>

  <newtok>
    <p> <code>More Binding Point</code> </p>
    <function name="bindBuffer" type="void">
      <param name="target" type="GLenum"/>
      <param name="buffer" type="WebGLBuffer"/>
      <code>target</code> accept the following parameters.
      <br/>
      <table width="30%">
        <tr><th>target</th></tr>
        <tr><td>ATOMIC_COUNTER_BUFFER</td></tr>
        <tr><td>DISPATCH_INDIRECT_BUFFER</td></tr>
        <tr><td>DRAW_INDIRECT_BUFFER</td></tr>
        <tr><td>SHADER_STORAGE_BUFFER</td></tr>
      </table>
      For <code>bindBufferRange</code> and <code>bindBufferBase</code>, only <code>ATOMIC_COUNTER_BUFFER</code> and <code>SHADER_STORAGE_BUFFER</code> are supported.
    </function>
  </newtok>

    BUFFER_ACCESS_FLAGS is not exposed to getBufferParameter, why?
    We only have BUFFER_USAGE and BUFFER_SIZE via getBufferParameter

  <newtok>
    <p> <code>Setting and Getting State</code> </p>
    <function name="getParameter" type="any">
      <param name="pname" type="GLenum"/>
      <code>pname</code> accept the following parameters.
      The return type of this method now depends on the parameter queried.
      <br/>
      <table width="30%">
        <tr><th>pname</th><th>returned type</th></tr>
        <tr><td>MAX_SAMPLE_MASK_WORDS</td><td>GLuint</td></tr>
        <tr><td>MAX_COLOR_TEXTURE_SAMPLES</td><td>GLuint</td></tr>
        <tr><td>MAX_DEPTH_TEXTURE_SAMPLES</td><td>GLuint</td></tr>
        <tr><td>MAX_INTEGER_SAMPLES</td><td>GLuint</td></tr>
        <tr><td>TEXTURE_BINDING_2D_MULTISAMPLE</td><td>WebGLTexture</td></tr>

        <tr><td>MAX_VERTEX_ATOMIC_COUNTER_BUFFERS</td><td>GLuint</td></tr>
		<tr><td>MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS</td><td>GLuint</td></tr>
		<tr><td>MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS</td><td>GLuint</td></tr>
        <tr><td>MAX_COMBINED_ATOMIC_COUNTER_BUFFERS</td><td>GLuint</td></tr>
        <tr><td>MAX_ATOMIC_COUNTER_BUFFER_BINDINGS</td><td>GLuint</td></tr>

        <tr><td>MAX_VERTEX_ATOMIC_COUNTERS</td><td>GLuint</td></tr>
        <tr><td>MAX_FRAGMENT_ATOMIC_COUNTERS</td><td>GLuint</td></tr>
        <tr><td>MAX_COMPUTE_ATOMIC_COUNTERS</td><td>GLuint</td></tr>
        <tr><td>MAX_COMBINED_ATOMIC_COUNTERS</td><td>GLuint</td></tr>

        <tr><td>ATOMIC_COUNTER_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>

        <tr><td>MAX_COMBINED_SHADER_STORAGE_BLOCKS</td><td>GLuint</td></tr>
        <tr><td>MAX_COMPUTE_SHADER_STORAGE_BLOCKS</td><td>GLuint</td></tr>
        <tr><td>MAX_FRAGMENT_SHADER_STORAGE_BLOCKS</td><td>GLuint</td></tr>
        <tr><td>MAX_VERTEX_SHADER_STORAGE_BLOCKS</td><td>GLuint</td></tr>
        <tr><td>MAX_SHADER_STORAGE_BLOCK_SIZE</td><td>GLuint</td></tr>
        <tr><td>MAX_SHADER_STORAGE_BUFFER_BINDINGS</td><td>GLuint</td></tr>

        <tr><td>SHADER_STORAGE_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>

      </table>
    </function>

    <function name="getIndexedParameter" type="any">
      <param name="target" type="GLenum"/>
      <param name="index" type="GLuint"/>
      <code>target</code> accept the following parameters.
      The return type of this method now depends on the parameter queried.
      <br/>
      <table width="30%">
        <tr><th>target</th><th>returned type</th></tr>
		<tr><td>VERTEX_BINDING_OFFSET</td><td>GLintptr</td></tr>
		<tr><td>VERTEX_BINDING_STRIDE</td><td>GLint</td></tr>
		<tr><td>VERTEX_BINDING_DIVISOR</td><td>GLint</td></tr>
		<tr><td>VERTEX_BINDING_BUFFER</td><td>WebGLBuffer</td></tr>

		<tr><td>SAMPLE_MASK_VALUE</td><td>GLbitfield</td></tr>

        <tr><td>ATOMIC_COUNTER_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
        <tr><td>ATOMIC_COUNTER_BUFFER_START</td><td>GLintptr</td></tr>
        <tr><td>ATOMIC_COUNTER_BUFFER_SIZE</td><td>GLsizeiptr</td></tr>

		<tr><td>IMAGE_BINDING_NAME</td><td>WebGLTexture</td></tr>
		<tr><td>IMAGE_BINDING_LEVEL</td><td>GLint</td></tr>
		<tr><td>IMAGE_BINDING_LAYERED</td><td>GLboolean</td></tr>
		<tr><td>IMAGE_BINDING_LAYER</td><td>GLint</td></tr>
		<tr><td>IMAGE_BINDING_ACCESS</td><td>GLenum</td></tr>
		<tr><td>IMAGE_BINDING_FORMAT</td><td>GLenum</td></tr>

		<tr><td>SHADER_STORAGE_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
        <tr><td>SHADER_STORAGE_BUFFER_START</td><td>GLintptr</td></tr>
		<tr><td>SHADER_STORAGE_BUFFER_SIZE</td><td>GLsizeiptr</td></tr>

		<tr><td>MAX_COMPUTE_WORK_GROUP_COUNT</td><td>GLint</td></tr>
		<tr><td>MAX_COMPUTE_WORK_GROUP_SIZE</td><td>GLint</td></tr>
      </table>
    </function>
    <function name="getProgramParameter" type="any">
      <param name="program" type="WebGLProgram?"/>
      <param name="pname" type="GLenum"/>
	  Query program parameter <code>pname</code> give <code>program</code>. See glGetProgramiv at
      <span class="gl-spec">
        <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.1/es_spec_3.1.pdf#nameddest=section-7.12">
          OpenGL ES 3.1 Section 7.12</a>,
        and <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glGetProgramiv.xhtml"
          class="nonnormative">man page</a>
      </span>
      <br/>
      The requested pname and its return type are given in the following table:
      <br/>
      <table width="30%">
        <tr><th>pname</th><th>returned type</th></tr>
        <tr><td>PROGRAM_SEPRARABLE</td><td>GLboolean</td></tr>
        <tr><td>COMPUTE_WORK_GROUP_SIZE</td><td>GLint</td></tr>
        <tr><td>ACTIVE_ATOMIC_COUNTER_BUFFERS</td><td>GLint</td></tr>
      </table>
    </function>
  </newtok>

  <!-- Refer to the <http://www.opengl.org/registry/doc/template.txt> OpenGL
       extension template for a description of these sections. These sections
       should be eliminated for WebGL extensions simply mirroring OpenGL or
       OpenGL ES extensions.
  -->

  <!-- these take   markup as contents -->


  <!-- Additions to the WebGL Specification -->


  <!-- New Implementation-Dependent State -->

  <diffwebgl2>
	  <h3>This extension can support GLSL ES 310</h3>

	  <h3>Integer format renderbuffer</h3>
	  <p> Renderbuffer can support integer format via RenderbufferStorage() </p>

  </diffwebgl2>

  <diffes31>
	<h3>Resource usage limitation in shader </h3>
    <p>shader storage buffer, atomic counter buffer and image unit can be used in vertex shader, fragment shader and compute shader. 
	  But in HLSL, the corresponding resources are only accessed by pixel shader and compute shader. So this extension limit these
	  resource access to fragment shader and compute shader.
    </p>

    <h3>gl_HelperInvocation issue </h3>
	<p>gl_HelperInvocation is a built-in input variable of fragment shader introduced in ESSL 310 (Chapter 7.1.2 Page 106). It needs
      at least GLSL 450 on desktop OpenGL, and it has no equivalent in HLSL system values in D3D11.
    </p>

    <h3> Paticular numbers in compute shader </h3>
    <p>Define the const and non-const behavior for some corner case like NaN, Inf, 0.0 in compute shader</p>
  </diffes31>

  <samplecode>
 <p>XXX IGNORE THIS SAMPLE CODE. IT HAS NOT YET BEEN UPDATED TO MATCH THE
    NEW SPEC TEXT. XXX</p>

  </samplecode>

  <history>
    <!-- a list of revisions in any order -->

    <!-- Include important changes in the evolution of the extension. It's
         especially important to include this section if the extension is modified
         after a version has been shipped. Consult the
         <http://www.opengl.org/registry/doc/template.txt> OpenGL extension template
         for an example.
    -->

    <revision date="2017/9/19">
      <!-- a list of changes -->

      <change>This initial version</change>

    </revision>
  </history>
</proposal>
