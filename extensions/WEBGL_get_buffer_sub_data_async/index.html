<!DOCTYPE html>
<!--AUTOGENERATED FILE - DO NOT EDIT - SEE Makefile-->
<html><head><meta charset="UTF-8"/><title>WebGL WEBGL_get_buffer_sub_data_async Extension Draft Specification</title><link rel="alternate" type="text/xml" href="extension.xml"/><link rel="stylesheet" type="text/css" href="../../resources/Khronos-WD.css"/></head><body><!--begin-logo--><div class="left"><a href="http://webgl.org/"><img alt="WebGL" height="100" src="../../resources/WebGL-Logo.png" width="240"/></a></div><div class="right"><a href="http://khronos.org/"><img alt="Khronos" height="60" src="../../resources/KhronosGroup-3D.png" width="220"/></a></div><div style="clear: both;">Â </div><br/><!--end-logo--><h1>WebGL WEBGL_get_buffer_sub_data_async Extension Draft Specification</h1><h2 class="no-toc">Name</h2><p>WEBGL_get_buffer_sub_data_async</p><h2 class="no-toc">Contact</h2><p>
    <a href="https://www.khronos.org/webgl/public-mailing-list/">WebGL working group</a> (public_webgl 'at' khronos.org)
  </p><h2 class="no-toc">Contributors</h2><p>Kai Ninomiya, Google Inc.</p><p>Members of the WebGL working group</p><h2 class="no-toc">Version</h2><p> Last modified date: December 13, 2016<br/>
          Revision: 1</p><h2 class="no-toc">Number</h2><p> WebGL extension #34</p><h2 class="no-toc">Dependencies</h2>
    <p> Written against the <a href="http://www.khronos.org/registry/webgl/specs/2.0/">WebGL API 2.0</a> specification. </p>
  <h2 class="no-toc">Overview</h2>
    <p>
      This extension allows asynchronous buffer readback in WebGL 2.0.
    </p>
    <p> When this extension is enabled: </p><ul><li>
        This extension exposes an asynchronous buffer readback entry point for
        non-blocking readbacks from WebGL buffers. It is equivalent to
        <code>getBufferSubData</code> but returns a <code>Promise</code>
        instead of an immediate readback result.
      </li></ul>
  <h2 class="no-toc">IDL</h2><pre class="idl">
[NoInterfaceObject]
interface WEBGL_get_buffer_sub_data_async {
  // Asynchronous version of getBufferSubData which fulfills the returned promise when the data becomes available.
  Promise&lt;ArrayBuffer&gt; getBufferSubDataAsync(GLenum target, GLintptr srcByteOffset, ArrayBufferView dstBuffer,
                                                   optional GLuint dstOffset = 0, optional GLuint length = 0); // May throw DOMException
};
  </pre><h2 class="no-toc">New Functions</h2><dl class="methods"><dt class="idl-code">Promise&lt;ArrayBuffer&gt; getBufferSubDataAsync(GLenum target, GLintptr srcByteOffset, ArrayBufferView dstBuffer, optional GLuint dstOffset, optional GLuint length)</dt><dd>
      
      
      
      
      
      Reads back data asynchronously from the bound WebGLBuffer into <code>dstBuffer</code>.
      <br/><br/>
      Let <code>buf</code> be the buffer bound to <code>target</code> at the time
      <code>getBufferSubDataAsync</code> is called.
      If <code>length</code> is 0, let <code>copyLength</code> be
      <code>dstBuffer.length - dstOffset</code>; otherwise, let
      <code>copyLength</code> be <code>length</code>.
      <br/><br/>
      If <code>copyLength</code> is greater than zero,
      copy <code>copyLength</code> typed elements (each of size <code>dstBuffer.BYTES_PER_ELEMENT</code>)
      from <code>buf</code> into <code>dstBuffer</code>,
      reading <code>buf</code> starting at byte index <code>srcByteOffset</code> and
      writing into <code>dstBuffer</code> starting at element index <code>dstOffset</code>.
      If <code>copyLength</code> is 0, no data is written to <code>dstBuffer</code>, but
      this does not cause a GL error to be generated.
      <ul>
        <li>If no WebGLBuffer is bound to <code>target</code>,
            an <code>INVALID_OPERATION</code> error is generated.
        </li>
        <li>If <code>target</code> is <code>TRANSFORM_FEEDBACK_BUFFER</code>,
            and any transform feedback object is currently active,
            an <code>INVALID_OPERATION</code> error is generated.
        </li>
        <li>If <code>dstOffset</code> is greater than <code>dstBuffer.length</code>,
            an <code>INVALID_VALUE</code> error is generated.
        </li>
        <li>If <code>dstOffset + copyLength</code> is greater than <code>dstBuffer.length</code>,
            an <code>INVALID_VALUE</code> error is generated.
        </li>
        <li>If <code>srcByteOffset</code> is less than zero,
            an <code>INVALID_VALUE</code> error is generated.
        </li>
        <li>If <code>srcByteOffset + copyLength*dstBuffer.BYTES_PER_ELEMENT</code>
            is larger than the length of <code>buf</code>,
            an <code>INVALID_OPERATION</code> is generated.
        </li>
      </ul>
      When invoked, <code>getBufferSubDataAsync</code> must run these steps:
      <ul>
        <li>Let <code>promise</code> be a Promise to be returned.
        </li>
        <li>Check for the errors defined above. If there are any errors, generate the GL error
          synchronously and
          <a href="https://www.w3.org/2001/tag/doc/promises-guide/#reject-promise">reject</a>
          <code>promise</code> with an <code>InvalidStateError</code>.
        </li>
        <li>Insert a readback of <code>buf</code> into the GL command stream, using the range
          defined above.
        </li>
        <li>Return <code>promise</code>, but continue running these steps in parallel.
        </li>
        <li>Upon completion of the readback, queue a task performing the following steps:
          <ul>
            <li>If the context has been lost, or if <code>dstBuffer</code> has been neutered,
              <a href="https://www.w3.org/2001/tag/doc/promises-guide/#reject-promise">reject</a>
              <code>promise</code> with an <code>InvalidStateError</code>. In this case, no GL
              error is generated.
            </li>
            <li>Write the readback result into <code>dstBuffer</code>, using the range defined
              above.
            </li>
            <li><a href="https://www.w3.org/2001/tag/doc/promises-guide/#resolve-promise">Resolve</a>
              <code>promise</code> with <code>dstBuffer</code>.
            </li>
          </ul>
          The task source for this task is the <a href="#WEBGLCONTEXTEVENT">WebGL task source</a>.
        </li>
      </ul>
      If the returned Promise is rejected, no data is written to <code>dstBuffer</code>.

      <div class="note">
        Even if <code>getBufferSubDataAsync</code> is called multiple times in a row with the same
        <code>dstBuffer</code>, <code>then</code> callbacks added synchronously will never see
        results of subsequent <code>getBufferSubDataAsync</code> calls.
      </div>

      <div class="note rationale">
        Compared to the synchronous version of <code>getBufferSubData</code>, this version may
        impose less overhead on applications. Intended use cases include reading pixels into a
        pixel buffer object and examining that data on the CPU. It does not force the graphics
        pipeline to be stalled as <code>getBufferSubData</code> does.
      </div>
    </dd></dl><h2 class="no-toc">Revision History</h2><p>Revision 1, 2016/12/13</p><ul><li>Initial revision.</li></ul></body></html>
