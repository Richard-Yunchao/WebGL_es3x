<!DOCTYPE html>
<!--AUTOGENERATED FILE - DO NOT EDIT - SEE Makefile-->
<html><head><meta charset="UTF-8"/><title>WebGL WEBGL_subscribe_uniform Extension Rejected Specification</title><link rel="alternate" type="text/xml" href="extension.xml"/><link rel="stylesheet" type="text/css" href="../../../resources/Khronos-Rejected.css"/></head><body><!--begin-logo--><div class="left"><a href="http://webgl.org/"><img alt="WebGL" height="100" src="../../../resources/WebGL-Logo.png" width="240"/></a></div><div class="right"><a href="http://khronos.org/"><img alt="Khronos" height="60" src="../../../resources/KhronosGroup-3D.png" width="220"/></a></div><div style="clear: both;">Â </div><br/><!--end-logo--><h1>WebGL WEBGL_subscribe_uniform Extension Rejected Specification</h1><h2 class="no-toc">Name</h2><p>WEBGL_subscribe_uniform</p><h2 class="no-toc">Contact</h2><p> <a href="https://www.khronos.org/webgl/public-mailing-list/">WebGL
  working group</a> (public_webgl 'at' khronos.org) </p><h2 class="no-toc">Contributors</h2><p>Owen Glofcheski, Google</p><p>Members of the WebGL working group</p><h2 class="no-toc">Version</h2><p> Last modified date: April 14, 2016<br/>
          Revision: 2</p><h2 class="no-toc">Number</h2><p> WebGL extension #NN</p><h2 class="no-toc">Dependencies</h2>
    <p> Written against the <a href="http://www.khronos.org/registry/webgl/specs/1.0/">WebGL API 1.0</a> specification. </p>
  <h2 class="no-toc">Overview</h2>
    <p> This extension exposes the ability to subscribe to a set of uniform targets 
        which can be used to populate uniforms within shader programs. This extension
        is generic, but currently only supports mouse position as a subscription target.
    </p><p>Background: 
    </p><p>The depth of the web pipeline makes it difficult to support low latency 
           interaction as event information retrieved via javascript
           is outdated by the time it's displayed to clients. By populating event 
           information later in the pipeline one can reduce perceived input latency.
    </p><p>This extension creates a new buffer type <code>'Valuebuffer'</code> to 
           maintain the active state for predefined subscription targets. Since a
           mechanism for buffering uniform information isn't available pre 2.0 (UBOs)
           an additional data type was needed. See 'New Types' for additional 
           information.</p>
    <p> When this extension is enabled: </p>
    <ul>
      <li>This extension provides a mechanism to store mouse positional information 
          in buffers and defer modification of uniform variables which use mouse 
          positional information until the WebGL commands are executed.
      </li>
      <li>This extension provides a mechanism to explicitly update mouse 
          positional information to maintain per frame consistency.
      </li>
    </ul>
  <h2 class="no-toc">IDL</h2><pre class="idl">
[NoInterfaceObject]
interface WEBGL_subscribe_uniform {
  const GLenum SUBSCRIBED_VALUES_BUFFER = 0x924B;

  // subscription targets
  const GLenum MOUSE_POSITION = 0x924C;

  WebGLValuebuffer? createValuebuffer();
  void deleteValuebuffer(WebGLValuebuffer? buffer);
  void isValuebuffer(WebGLValuebuffer? buffer);
  void bindValuebuffer(GLenum target, WebGLValuebuffer? buffer);

  void subscribeValue(GLenum traget, GLenum subscription);
  void populateSubscribedValues(GLenum target);
  void uniformValuebuffer(WebGLUniformLocation? location, GLenum target, GLenum subscription);
}; // interface WEBGL_subscribe_uniform
  </pre><h2 class="no-toc">New Functions</h2><dl class="methods"><dt class="idl-code">WebGLValuebuffer createValuebuffer()</dt><dd>
    Creates and returns a <code>Valuebuffer</code> object.</dd><dt class="idl-code">void deleteValuebuffer(WebGLValuebuffer buffer)</dt><dd>Deletes a <code>Valuebuffer</code>
    object.</dd><dt class="idl-code">bool isValuebuffer(WebGLValuebuffer buffer)</dt><dd>Returns whether an object is a 
    <code>Valuebuffer</code> object.</dd><dt class="idl-code">void bindValuebuffer(GLenum target, WebGLValuebuffer buffer)</dt><dd>Lets you use a named 
    <code>Valuebuffer</code> object.</dd><dt class="idl-code">void subscribeValuebuffer(GLenum target, GLenum subscription)</dt><dd>Subscribes the currently bound 
    <code>Valuebuffer</code> object to a subscription target.</dd><dt class="idl-code">void populateSubscribedValues(GLenum target)</dt><dd>Populates the currently bound 
    <code>Valuebuffer</code> object with the state of the subscriptions to
    which it is subscribed.</dd><dt class="idl-code">void uniformValuebuffer(WebGLUniformLocation location, GLenum target, GLenum subscription)</dt><dd>Modifies the value of a uniform variable
    or uniform variable array using the state of the subscription target in the
    currently bound <code>Valuebuffer</code> object.</dd></dl><h2 class="no-toc">New Types</h2><p>A <code>Valuebuffer</code> abstracts the mapping of subscription targets to internal 
       state and acts as a single storage object for subscription information (e.g. current 
       mouse position). Clients can then use the objects data to populate uniform variables.</p><p>Post WebGL API 2.0, this abstraction could exist as a layer ontop of UBOs
       which managers the mapping of subscription targets to internal state and the mapping
       of subscription targets to offsets within the buffer. The UBO would be used to store the 
       active buffer state as well as the uniform location mapping. Clients would be required to
       state all their subscription targets at once to allocate the appropriate amount of memory. 
       Aside from this small change the implementation is essentially the same, with UBOs replacing
       <code>Valuebuffers</code> and relevant create, delete, bind methods being replaced.
       Additionally, the inclusion of UBOs would replace the need for 
       <code>uniformValueBuffer(...)</code>.</p><dl class="methods"><dt class="idl-code">[NoInterfaceObject]<br/>interface <em>WebGLValuebuffer</em> {<br/>};</dt><dd>
      <p>This interface is used to maintain a reference to internal 
      <code>Valuebuffer</code> subscription states.</p>
    </dd></dl><h2 class="no-toc">New Tokens</h2><dl class="methods"><dt class="idl-code">any bindValuebuffer(GLenum target, WebGLValuebuffer buffer)</dt><dd>
    <p><code>SUBSCRIBED_VALUES_BUFFER</code> 
    is accepted as the target parameter to bindValuebuffer</p></dd><dt class="idl-code">void subscribeValuebuffer(GLenum target, GLenum subscription)</dt><dd>
    <p><code>SUBSCRIBED_VALUES_BUFFER</code> 
    is accepted as the target parameter to subscribeValuebuffer</p>
    <p><code>MOUSE_POSITION</code> 
    is accepted as the subscription parameter to subscribeValuebuffer</p></dd><dt class="idl-code">void populateSubscribedValues(GLenum target)</dt><dd>
    <p><code>SUBSCRIBED_VALUES_BUFFER</code> 
    is accepted as the target parameter to populateSubscribedValues</p></dd><dt class="idl-code">void uniformValuebuffer(WebGLUniformLocation location, GLenum target, GLenum subscription)</dt><dd>
    <p><code>SUBSCRIBED_VALUES_BUFFER</code> 
    is accepted as the target parameter to uniformValuebuffer</p>
    <p><code>MOUSE_POSITION</code> 
    is accepted as the subscription parameter to uniformValuebuffer</p></dd></dl><h2 class="no-toc">Sample Code</h2><div class="example"><pre xml:space="preserve">
&lt;script id="vshader" type="x-shader/x-vertex"&gt;
  uniform ivec2 uMousePosition;

  void main()
  {
    gl_Position = vec4(uMousePosition, 0, 1);
  }
&lt;/script&gt;

function init(gl) {
  shader.uMousePosition = gl.getUniformLocation(shader, "uMousePosition");
  ...

  var ext = gl.getExtension('WEBGL_subscribe_uniform');
    
  // Create the value buffer and subscribe.
  var valuebuffer = ext.createValuebuffer();
  ext.bindValuebuffer(SUBSCRIBED_VALUES_BUFFER, valuebuffer);
  ext.subscribeValue(MOUSE_POSITION);
  ...
}
     
function draw(gl) {   
  // Populate buffer and populate uniform
  ext.bindValuebuffer(SUBSCRIBED_VALUES_BUFFER, valuebuffer);
  ext.populateSubscribedValues(SUBSCRIBED_VALUES_BUFFER);
  ext.uniformValuebuffer(shader.uMousePosition,
                         SUBSCRIBED_VALUES_BUFFER,
                         MOUSE_POSITION);

  gl.drawElements(...);
}
  </pre></div><h2 class="no-toc">Issues</h2><h2 class="no-toc">Revision History</h2><p>Revision 1, 2014/11/13</p><ul><li>Initial revision.</li></ul><p>Revision 2, 2016/04/14</p><ul><li>Moved to rejected state. Does not have a champion at this point. Was difficult to
      reason about how to use the extension, given that the on-screen rendering would be farther
      ahead than the application's state. Seems that the best solution is to focus on reducing the
      depth, and therefore latency, of the browser's rendering pipeline.</li></ul></body></html>
